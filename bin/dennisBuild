#!/usr/bin/env perl -T

use strict;
use warnings;

use File::Copy "cp";

# Untaint a path safely
sub untaint_path {
    my ($path) = @_;
    if ($path =~ /^([-\/\w\.\_]+)$/) {
        return $1;
    }
    die "Insecure path detected: $path";
}

# Load and untaint configuration
our ($date, $domainName, $serverName, $dnshome, $fileSerial, $fileHosts, $fileNameServers, $fileForZone);
require "/var/named/etc/dennis.conf";

$ENV{PATH} = '/bin:/usr/bin'; # Set a safe execution path

# Untaint config values
if ($date =~ /^(.*)$/s) { $date = $1; } else { die "Tainted date: $date"; }
if ($domainName =~ /^(.*)$/s) { $domainName = $1; } else { die "Tainted domainName: $domainName"; }
if ($serverName =~ /^(.*)$/s) { $serverName = $1; } else { die "Tainted serverName: $serverName"; }
$dnshome = untaint_path($dnshome);
$fileSerial = untaint_path($fileSerial);
$fileHosts = untaint_path($fileHosts);
$fileNameServers = untaint_path($fileNameServers);
$fileForZone = untaint_path($fileForZone);

chomp($date);

# Simple filehandle cache
my %file_handles;

sub get_fh {
    my ($path) = @_;
    my $clean_path = untaint_path($path);
    unless (exists $file_handles{$clean_path}) {
        open my $fh, '>', $clean_path or die "Cannot open file '$clean_path' for writing: $!";
        $file_handles{$clean_path} = $fh;
        printHeader($fh); # Print header on first open
    }
    return $file_handles{$clean_path};
}

# --- Subroutine Declarations ---
sub printHeader;
sub removeFiles;
sub createLookup;
sub createBindZoneConf;
sub createBind9ZoneConf;
sub localHostnameHack;

# --- Main Logic ---
my $contactName = "hostmaster.${domainName}";
my $fileBuildLock = untaint_path("$dnshome/locks/dnsBuild.lock");

my $serialdate_tainted = `date '+%Y%m%d'`;
my $serialdate;
if ($serialdate_tainted =~ /^(\d{8})$/) {
    $serialdate = $1;
} else {
    die "Got tainted data from date command: $serialdate_tainted";
}
my $serial;

if (-e $fileBuildLock) {
    die "ERROR: DNS is currently rebuilding. If you are sure that this is not the case, then remove $fileBuildLock\n";
}

open(my $lock_fh, '>', $fileBuildLock) or die "Cannot create lock file $fileBuildLock: $!";
close($lock_fh);

# Atomically read and update the serial number
open(my $serial_fh, '+<', $fileSerial) or open($serial_fh, '>', $fileSerial) or die "Cannot open or create $fileSerial: $!";
flock($serial_fh, 2); # Exclusive lock
my $serial_content = do { local $/; <$serial_fh> };
my $is_empty = !defined $serial_content || $serial_content eq '';

if ($is_empty) {
    $serial = "${serialdate}00";
} else {
    if ($serial_content =~ /^(\d+)\s*$/) {
        my $read_serial = $1;
        if ($read_serial =~ /^$serialdate/) {
            $serial = $read_serial + 1;
        } else {
            $serial = "${serialdate}00";
        }
    } else {
        die "Invalid serial number format in $fileSerial: $serial_content";
    }
}
seek($serial_fh, 0, 0);
truncate($serial_fh, 0);
print $serial_fh "$serial\n";
close($serial_fh);

# Read hosts file
open(my $dns_fh, '<', $fileHosts) or die "Cannot open $fileHosts: $!";
my @dnsArray = <$dns_fh>;
close($dns_fh);

# Create a unique list of reverse zones (e.g., "1.2.3")
my %seen;
my @dnsReverseIP = grep { !$seen{$_}++ } map {
    my ($ip) = split(/\s+/, $_, 2);
    $ip =~ /^([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})\.[0-9]{1,3}$/ ? $1 : ()
} @dnsArray;

removeFiles();
createLookup(\@dnsArray);

# Append nameserver and MX info
open(my $ns_fh, '<', $fileNameServers) or die "Cannot open $fileNameServers: $!";
my $fwd_fh = get_fh($fileForZone);
while (my $line = <$ns_fh>) {
    print $fwd_fh $line;
}
close($ns_fh);

# Close all managed filehandles before creating the zone config
for my $fh (values %file_handles) {
    close $fh;
}

createBindZoneConf(\@dnsReverseIP);

unlink($fileBuildLock) or die "Cannot remove file $fileBuildLock: $!";

# --- Subroutines ---

sub createLookup {
    my ($lines) = @_;
    for my $line (@$lines) {
        $line =~ s/#.*//;
        chomp($line);
        next if $line =~ /^\s*$/;

        my @fields = split(/\s+/, $line);
        my $ip_tainted = shift(@fields) || '';
        my $hostname_tainted = shift(@fields) || '';

        my $ip;
        if ($ip_tainted =~ /^([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})$/) {
            $ip = $1;
        } else { next; }

        my $hostname;
        if ($hostname_tainted =~ /^([\w\-\.]+)$/) {
            $hostname = $1;
        } else { next; }

        my $fullhostname = localHostnameHack($hostname);
        my ($o1, $o2, $o3, $o4) = split(/\./, $ip);
        my $fileRevIP = untaint_path("$dnshome/master/$o1.$o2.$o3");

        my $fwd_fh = get_fh($fileForZone);
        printf $fwd_fh "%-24sIN\tA\t%s\n", $hostname, $ip;

        for my $alias_tainted (@fields) {
            if ($alias_tainted =~ /^([\w\-\.]+)$/) {
                printf $fwd_fh "%-24sIN\tCNAME\t%s\n", $1, $hostname;
            }
        }

        my $rev_fh = get_fh($fileRevIP);
        print $rev_fh "$o4\tIN\tPTR\t$fullhostname\n";
    }
}

sub createBindZoneConf {
    my ($reverse_zones) = @_;
    my $zoneDate;
    if ($date =~ /^([\w\.\-:]+)$/) {
        $zoneDate = $1;
    } else { die "Tainted date string: $date"; }

    my $fileZoneConf = untaint_path("$dnshome/etc/zones.bind");
    my $oldZoneConf = untaint_path("$dnshome/etc/save/zones.bind.$zoneDate");

    if (-f $fileZoneConf) {
        cp($fileZoneConf, $oldZoneConf) or die "Failed to copy $fileZoneConf: $!";
    }

    open(my $zc_fh, '>', $fileZoneConf) or die "Cannot open $fileZoneConf for writing: $!";
    createBind9ZoneConf($zc_fh, $reverse_zones);
    close($zc_fh);

    if (-f $oldZoneConf) {
        open(my $status_fh, '-|', 'cmp', $fileZoneConf, $oldZoneConf) or die "Cannot compare files";
        my $status = <$status_fh>;
        close($status_fh);
        unlink($oldZoneConf) unless defined($status);
    }
}

sub createBind9ZoneConf {
    my ($zc_fh, $reverse_zones) = @_;
    print $zc_fh "// zone information for $domainName domain\n";
    for my $rev_ip_path (@$reverse_zones) {
        my ($o1, $o2, $o3) = split(/\./, $rev_ip_path);
        my $revIP = "$o3.$o2.$o1";
        printf $zc_fh "zone \"%s.in-addr.arpa\" {\n", $revIP;
        printf $zc_fh "\ttype master;\n";
        printf $zc_fh "\tfile \"%s/master/%s\";\n", $dnshome, $rev_ip_path;
        printf $zc_fh "};\n\n";
    }
}

sub localHostnameHack {
    my ($hostname) = @_; # Assumed untainted
    return ($hostname =~ /\.$/) ? $hostname : "$hostname.$domainName.";
}

sub removeFiles {
    my $master_dir = untaint_path("$dnshome/master");
    opendir(my $dh, $master_dir) or die "Cannot open directory $master_dir: $!";
    my @files = readdir($dh);
    closedir($dh);

    for my $file_tainted (@files) {
        next if $file_tainted =~ /^\.\.?$/;
        if ($file_tainted =~ /^([\w\.\-]+)$/) {
            my $file = $1;
            unlink("$master_dir/$file");
        }
    }
}

sub printHeader {
    my ($fh) = @_;
    my $serial_untainted = $serial; # Already validated
    print $fh "\$TTL 86400\n";
    print $fh "\@\tIN\tSOA\t$serverName.$domainName. $contactName. (\n";
    print $fh "\t\t$serial_untainted\t; Serial\n";
    print $fh "\t\t10800\t\t; Refresh after 3 hours\n";
    print $fh "\t\t3600\t\t; Retry after 1 hour\n";
    print $fh "\t\t604800\t\t; Expire after 1 week\n";
    print $fh "\t\t86400 )\t\t; Minimum TTL of 1 day\n";
    print $fh "\tIN\tNS\t$serverName.$domainName.\n";
}
